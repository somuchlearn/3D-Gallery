<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fine Art Print Konfigurator - Premium 3D Preview</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(to bottom, #e8e8e8, #d0d0d0);
            overflow: hidden;
            height: 100vh;
        }

        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        #controls {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.98);
            padding: 28px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0, 0, 0, 0.04);
            z-index: 100;
            max-width: 360px;
            border: 1px solid rgba(0, 0, 0, 0.06);
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 24px;
            margin-bottom: 6px;
            color: #111;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .subtitle {
            font-size: 13px;
            color: #666;
            margin-bottom: 24px;
            font-weight: 400;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: #333;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        input[type="file"] {
            display: none;
        }

        .file-upload-btn {
            display: block;
            width: 100%;
            padding: 16px;
            background: #000;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 1.2px;
        }

        .file-upload-btn:hover {
            background: #222;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        input[type="range"] {
            width: 100%;
            margin-top: 10px;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            border-radius: 2px;
            background: linear-gradient(to right, #000 0%, #ddd 0%);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #000;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #000;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .slider-value {
            display: inline-block;
            margin-left: 10px;
            color: #000;
            font-weight: 700;
            font-size: 13px;
        }

        select {
            width: 100%;
            padding: 14px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        select:hover {
            border-color: #000;
        }

        select:focus {
            outline: none;
            border-color: #000;
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
        }

        button {
            width: 100%;
            padding: 16px;
            margin-top: 12px;
            background: #000;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 1.2px;
        }

        button:hover {
            background: #222;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        #info {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(255, 255, 255, 0.98);
            padding: 20px 24px;
            border-radius: 12px;
            color: #555;
            font-size: 13px;
            max-width: 300px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 0, 0, 0.06);
            backdrop-filter: blur(10px);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            padding: 48px 72px;
            border-radius: 16px;
            font-size: 16px;
            font-weight: 600;
            color: #000;
            display: none;
            z-index: 200;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(0, 0, 0, 0.06);
        }

        .specs {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #e8e8e8;
            font-size: 12px;
            color: #666;
        }

        .specs-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .specs-label {
            font-weight: 600;
            color: #333;
        }

        /* Recording Indicator */
        .recording-indicator {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(220, 38, 38, 0.95);
            color: white;
            padding: 16px 32px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            z-index: 150;
            display: none;
            box-shadow: 0 4px 16px rgba(220, 38, 38, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .recording-indicator::before {
            content: '‚óè';
            display: inline-block;
            margin-right: 10px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .recording-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0%;
            height: 4px;
            background: linear-gradient(to right, #dc2626, #ef4444);
            transition: width 0.1s linear;
        }

        button.recording {
            background: #dc2626 !important;
            animation: pulse 2s infinite;
        }

        button.showcase-active {
            background: #dc2626 !important;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>

        <div id="controls">
            <h1>Fine Art Print</h1>
            <div class="subtitle">Premium Gallery Konfigurator</div>

            <div class="control-group">
                <label for="imageUpload">Ihr Kunstwerk</label>
                <input type="file" id="imageUpload" accept="image/*">
                <button class="file-upload-btn" onclick="document.getElementById('imageUpload').click()">
                    Bild hochladen
                </button>
            </div>

            <div class="control-group">
                <label for="printSize">Bildgr√∂√üe</label>
                <select id="printSize">
                    <option value="0.5">30 x 40 cm</option>
                    <option value="0.75">50 x 70 cm</option>
                    <option value="1.0" selected>70 x 100 cm</option>
                    <option value="1.25">100 x 140 cm</option>
                    <option value="1.5">120 x 180 cm</option>
                </select>
            </div>

            <div class="control-group">
                <label for="passepartout">Passepartout</label>
                <select id="passepartout">
                    <option value="0" selected>Ohne Passepartout</option>
                    <option value="3">3 cm</option>
                    <option value="5">5 cm</option>
                    <option value="7">7 cm</option>
                    <option value="10">10 cm</option>
                </select>
            </div>

            <div class="control-group">
                <label for="frameWidth">
                    Rahmenbreite <span class="slider-value" id="frameWidthValue">1</span> cm
                </label>
                <input type="range" id="frameWidth" min="1" max="5" value="1" step="0.5">
            </div>

            <div class="control-group">
                <label for="frameDepth">
                    Rahmentiefe <span class="slider-value" id="frameDepthValue">2</span> cm
                </label>
                <input type="range" id="frameDepth" min="1" max="3" value="2" step="0.5">
            </div>

            <div class="control-group">
                <label for="frameMaterial">Rahmenmaterial</label>
                <select id="frameMaterial">
                    <option value="black-wood" selected>Schwarzes Holz</option>
                    <option value="black-aluminum">Aluminium Schwarz (Premium)</option>
                    <option value="oak">Eiche Natur</option>
                    <option value="walnut">Nussbaum Dunkel</option>
                    <option value="white-wood">Wei√ües Holz</option>
                </select>
            </div>

            <div class="control-group">
                <label for="glassEffect">Verglasung</label>
                <select id="glassEffect">
                    <option value="none" selected>Ohne Glas</option>
                    <option value="glass">Normalglas</option>
                    <option value="acrylic">Acrylglas</option>
                    <option value="museum">Museumsglas</option>
                </select>
            </div>

            <div class="control-group">
                <label>Showcase & Video</label>
                <button id="showcaseBtn" disabled>SHOWCASE STARTEN</button>
                <button id="recordBtn" disabled>VIDEO AUFNEHMEN (1:1)</button>
            </div>

            <button id="exportBtn" disabled>3D Modell exportieren</button>

            <div class="specs">
                <div class="specs-item">
                    <span class="specs-label">Material:</span>
                    <span>Aluminium-Dibond</span>
                </div>
                <div class="specs-item">
                    <span class="specs-label">Befestigung:</span>
                    <span>Alu-Schienen</span>
                </div>
                <div class="specs-item">
                    <span class="specs-label">Finish:</span>
                    <span>Matt Premium</span>
                </div>
            </div>
        </div>

        <div id="info">
            <strong>Navigation:</strong><br>
            Linke Maustaste: Rotieren<br>
            Rechte Maustaste: Verschieben<br>
            Mausrad: Zoomen
        </div>

        <div id="recordingIndicator" class="recording-indicator">
            AUFNAHME L√ÑUFT
            <div class="recording-progress" id="recordingProgress"></div>
        </div>

        <div id="emptyState" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #666; font-size: 16px; pointer-events: none;">
            <div style="font-size: 64px; margin-bottom: 20px; opacity: 0.3;">üñºÔ∏è</div>
            <div style="font-weight: 600; margin-bottom: 10px;">Kein Bild geladen</div>
            <div style="font-size: 14px; opacity: 0.7;">Laden Sie ein Bild hoch, um die 3D-Vorschau zu sehen</div>
        </div>

        <div class="loading" id="loading">Wird verarbeitet...</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';

        let scene, camera, renderer, controls;
        let frameGroup = null;
        let currentTexture = null;
        let galleryWall = null;

        // Showcase Mode State
        let isShowcaseMode = false;
        let showcaseStartTime = 0;
        let showcaseAngle = 0;
        let showcaseRadius = 8;
        let showcaseCameraHeight = 1.5;
        let showcaseTargetZ = 1.5; // Z-Position des Frame-Zentrums
        let originalCameraPosition = null;
        let originalControlsEnabled = null;

        // Recording State
        let isRecording = false;
        let mediaRecorder = null;
        let recordedChunks = [];
        let originalRendererSize = { width: 0, height: 0 };
        let originalCameraAspect = 0;
        let originalPixelRatio = 0;

        // Configuration
        const SHOWCASE_ROTATION_SPEED = 0.898; // rad/sec (~7s f√ºr 360¬∞)
        const SHOWCASE_DURATION = Math.PI * 2 / SHOWCASE_ROTATION_SPEED;
        const RECORDING_WIDTH = 1080;
        const RECORDING_HEIGHT = 1080;
        const RECORDING_FPS = 60; // 60 FPS f√ºr maximale Fl√ºssigkeit
        const RECORDING_BITRATE = 12000000; // 12 Mbps f√ºr beste Qualit√§t

        // Easing-Funktion f√ºr sanfte Bewegungen
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Best Practice: BoundingBox-basierte Kamera-Positionierung
        function calculateOptimalShowcaseSettings(viewportAspectRatio = null) {
            if (!frameGroup) {
                return { radius: 10, height: 1.5 }; // Defaults
            }

            // BESTE METHODE: Verwende die tats√§chliche 3D BoundingBox des Frames
            const boundingBox = new THREE.Box3().setFromObject(frameGroup);
            const size = boundingBox.getSize(new THREE.Vector3());
            const center = boundingBox.getCenter(new THREE.Vector3());

            console.log('Frame Size:', {
                width: size.x.toFixed(3),
                height: size.y.toFixed(3),
                depth: size.z.toFixed(3)
            });

            // Maximale Dimension (wichtig f√ºr alle Orientierungen)
            const maxDimension = Math.max(size.x, size.y, size.z);

            // FOV = 35¬∞ (siehe camera setup)
            const fov = 35 * (Math.PI / 180);

            // Basis-Radius Berechnung mit gro√üz√ºgigem Puffer
            let optimalRadius = (maxDimension / 2) / Math.tan(fov / 2);

            // Gro√üz√ºgiger Puffer abh√§ngig vom Viewport
            if (viewportAspectRatio === 1.0) {
                // Recording Mode (1:1): Noch mehr Abstand!
                // Berechne Diagonale f√ºr worst-case
                const diagonal = Math.sqrt(size.x * size.x + size.y * size.y);
                const diagonalRadius = (diagonal / 2) / Math.tan(fov / 2);
                optimalRadius = Math.max(optimalRadius, diagonalRadius) * 1.8; // 80% extra Puffer
            } else {
                // Normaler Showcase Mode
                optimalRadius *= 1.6; // 60% Puffer
            }

            // Kamera-H√∂he: Exakt auf Frame-Zentrum
            const optimalHeight = center.y;

            console.log('Calculated Settings:', {
                radius: optimalRadius.toFixed(2) + 'm',
                height: optimalHeight.toFixed(2) + 'm',
                targetZ: center.z.toFixed(2) + 'm',
                mode: viewportAspectRatio === 1.0 ? 'Recording (1:1)' : 'Showcase'
            });

            return {
                radius: Math.max(optimalRadius, 6), // Minimum 6m Distanz
                height: Math.max(optimalHeight, 0.8), // Minimum 0.8m H√∂he
                targetZ: center.z // Z-Position des Frame-Zentrums
            };
        }

        function init() {
            scene = new THREE.Scene();

            // Gradient background for professional look
            const canvas = document.createElement('canvas');
            canvas.width = 2;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#e8e8e8');
            gradient.addColorStop(1, '#d0d0d0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 2, 512);
            const bgTexture = new THREE.CanvasTexture(canvas);
            scene.background = bgTexture;

            // No fog for clean infinity background

            camera = new THREE.PerspectiveCamera(
                35,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1, 10);

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                preserveDrawingBuffer: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            // Shadows disabled for better performance
            renderer.shadowMap.enabled = false;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.12; // Very smooth, professional feel
            controls.rotateSpeed = 0.8; // Controlled rotation
            controls.zoomSpeed = 0.8;
            controls.panSpeed = 0.5;
            controls.minDistance = 2.5; // Allow closer viewing
            controls.maxDistance = 12; // Tighter range for focused experience
            controls.maxPolarAngle = Math.PI; // Allow full rotation
            controls.target.set(0, 0, 1.5); // Target the frame center
            controls.enablePan = true;
            controls.screenSpacePanning = false;

            // Create simple environment for reflections
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            const envScene = new THREE.Scene();
            envScene.background = new THREE.Color(0xffffff);

            const envLight1 = new THREE.DirectionalLight(0xffffff, 2);
            envLight1.position.set(1, 1, 1);
            envScene.add(envLight1);

            const envLight2 = new THREE.AmbientLight(0xffffff, 1);
            envScene.add(envLight2);

            const envMap = pmremGenerator.fromScene(envScene).texture;
            scene.environment = envMap;

            // Gallery Wall - Removed for infinity background effect
            // createGalleryWall();

            // Optimized Lighting - Simple & Fast
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.8);
            scene.add(ambientLight);

            // Single directional light for definition
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
            mainLight.position.set(3, 5, 7);
            scene.add(mainLight);

            window.addEventListener('resize', onWindowResize, false);

            document.getElementById('imageUpload').addEventListener('change', handleImageUpload);
            document.getElementById('frameWidth').addEventListener('input', updateFrame);
            document.getElementById('frameDepth').addEventListener('input', updateFrame);
            document.getElementById('printSize').addEventListener('input', updateFrame);
            document.getElementById('passepartout').addEventListener('input', updateFrame);
            document.getElementById('frameMaterial').addEventListener('input', updateFrame);
            document.getElementById('glassEffect').addEventListener('input', updateFrame);
            document.getElementById('exportBtn').addEventListener('click', exportModel);
            document.getElementById('showcaseBtn').addEventListener('click', toggleShowcase);
            document.getElementById('recordBtn').addEventListener('click', toggleRecording);

            // Update range slider backgrounds
            updateSliderBackground('frameWidth');
            updateSliderBackground('frameDepth');

            animate();
        }

        function createGalleryWall() {
            // Subtle backdrop - only visible behind frame, no distracting floor
            const wallGeometry = new THREE.PlaneGeometry(15, 12);
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0xebebeb,
                roughness: 0.95,
                metalness: 0.0,
                opacity: 0.6,
                transparent: true,
            });
            galleryWall = new THREE.Mesh(wallGeometry, wallMaterial);
            galleryWall.position.z = -3.5;
            galleryWall.receiveShadow = true;
            scene.add(galleryWall);

            // No floor - clean product presentation
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateSliderBackground(sliderId) {
            const slider = document.getElementById(sliderId);
            const min = slider.min;
            const max = slider.max;
            const value = slider.value;
            const percentage = ((value - min) / (max - min)) * 100;
            slider.style.background = `linear-gradient(to right, #000 0%, #000 ${percentage}%, #ddd ${percentage}%, #ddd 100%)`;
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('loading').style.display = 'block';
            document.getElementById('emptyState').style.display = 'none';

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    createTextureFromImage(img);
                    createFramedPrint();
                    document.getElementById('loading').style.display = 'none';
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function createTextureFromImage(img) {
            const texture = new THREE.Texture(img);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            currentTexture = texture;
        }

        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Dark wood base
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, 512, 512);

            // Wood grain
            for (let i = 0; i < 100; i++) {
                ctx.strokeStyle = `rgba(${15 + Math.random() * 10}, ${15 + Math.random() * 10}, ${15 + Math.random() * 10}, ${0.3 + Math.random() * 0.3})`;
                ctx.lineWidth = Math.random() * 2;
                ctx.beginPath();
                const y = Math.random() * 512;
                ctx.moveTo(0, y);
                ctx.bezierCurveTo(
                    128, y + (Math.random() - 0.5) * 20,
                    384, y + (Math.random() - 0.5) * 20,
                    512, y
                );
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createFramedPrint() {
            if (!currentTexture) return;

            if (frameGroup) {
                scene.remove(frameGroup);
                frameGroup.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => {
                                if (m.map) m.map.dispose();
                                m.dispose();
                            });
                        } else {
                            if (child.material.map) child.material.map.dispose();
                            child.material.dispose();
                        }
                    }
                });
            }

            const frameWidth = parseFloat(document.getElementById('frameWidth').value) / 10;
            const frameDepth = parseFloat(document.getElementById('frameDepth').value) / 10;
            const printSizeMultiplier = parseFloat(document.getElementById('printSize').value);
            const passepartoutWidth = parseFloat(document.getElementById('passepartout').value) / 10;
            const glassType = document.getElementById('glassEffect').value;

            document.getElementById('frameWidthValue').textContent = (frameWidth * 10).toFixed(1);
            document.getElementById('frameDepthValue').textContent = (frameDepth * 10).toFixed(1);

            updateSliderBackground('frameWidth');
            updateSliderBackground('frameDepth');

            const img = currentTexture.image;
            const aspectRatio = img.width / img.height;

            const printHeight = 4 * printSizeMultiplier;
            const printWidth = printHeight * aspectRatio;

            const totalWidth = printWidth + (passepartoutWidth * 2);
            const totalHeight = printHeight + (passepartoutWidth * 2);

            frameGroup = new THREE.Group();

            // === PASSEPARTOUT (simple and clean) ===
            if (passepartoutWidth > 0) {
                // Main passepartout with subtle thickness
                const passepartoutThickness = 0.003;
                const passepartoutGeometry = new THREE.BoxGeometry(totalWidth, totalHeight, passepartoutThickness);
                const passepartoutMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf5f5f2,
                    roughness: 0.9,
                    metalness: 0.0,
                });
                const passepartoutMesh = new THREE.Mesh(passepartoutGeometry, passepartoutMaterial);
                passepartoutMesh.position.z = -0.015;
                passepartoutMesh.castShadow = true;
                frameGroup.add(passepartoutMesh);
            }

            // === PRINT (Fine Art Paper with subtle texture) ===
            const printGeometry = new THREE.PlaneGeometry(printWidth, printHeight);
            const printMaterial = new THREE.MeshStandardMaterial({
                map: currentTexture,
                roughness: 0.7,
                metalness: 0.0,
                side: THREE.FrontSide,
            });
            const printMesh = new THREE.Mesh(printGeometry, printMaterial);
            printMesh.position.z = 0;
            printMesh.castShadow = true;
            frameGroup.add(printMesh);

            // === GLASS with realistic 3D thickness ===
            if (glassType !== 'none') {
                let transmission, glassRoughness, reflectivity, glassThickness;

                switch(glassType) {
                    case 'museum':
                        transmission = 0.98;
                        glassRoughness = 0.01;
                        reflectivity = 0.03;
                        glassThickness = 0.002;
                        break;
                    case 'acrylic':
                        transmission = 0.96;
                        glassRoughness = 0.03;
                        reflectivity = 0.06;
                        glassThickness = 0.004;
                        break;
                    default:
                        transmission = 0.94;
                        glassRoughness = 0.05;
                        reflectivity = 0.08;
                        glassThickness = 0.003;
                }

                // Use BoxGeometry for realistic glass thickness visible from side
                const glassGeometry = new THREE.BoxGeometry(totalWidth, totalHeight, glassThickness);
                // Crystal-clear glass without milky transmission effect
                const glassMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.05, // Almost invisible, just subtle reflections
                    roughness: 0.02, // Very smooth for clarity
                    metalness: 0.0,
                    transmission: 0, // No transmission = no milky effect
                    ior: 1.52,
                    reflectivity: 0.15, // Subtle realistic glass reflections
                    envMapIntensity: 0.3, // Minimal environment reflections
                    clearcoat: 1.0, // High clearcoat for glass shine
                    clearcoatRoughness: 0.02, // Very smooth clearcoat
                });

                const glassMesh = new THREE.Mesh(glassGeometry, glassMaterial);
                glassMesh.position.z = 0.05;
                frameGroup.add(glassMesh);
            }

            // === FRAME with premium materials ===
            const selectedMaterial = document.getElementById('frameMaterial').value;
            let frameMaterial;

            switch(selectedMaterial) {
                case 'black-aluminum':
                    // Premium black aluminum - sleek and modern
                    frameMaterial = new THREE.MeshStandardMaterial({
                        color: 0x1a1a1a,
                        roughness: 0.15,
                        metalness: 0.9,
                        envMapIntensity: 1.2,
                    });
                    break;
                case 'oak':
                    // Natural oak wood
                    const oakTexture = createWoodTexture();
                    frameMaterial = new THREE.MeshStandardMaterial({
                        color: 0xc19a6b,
                        map: oakTexture,
                        roughness: 0.6,
                        metalness: 0.0,
                        envMapIntensity: 0.3,
                    });
                    break;
                case 'walnut':
                    // Dark walnut wood
                    const walnutTexture = createWoodTexture();
                    frameMaterial = new THREE.MeshStandardMaterial({
                        color: 0x3e2723,
                        map: walnutTexture,
                        roughness: 0.35,
                        metalness: 0.05,
                        envMapIntensity: 0.4,
                    });
                    break;
                case 'white-wood':
                    // White painted wood
                    frameMaterial = new THREE.MeshStandardMaterial({
                        color: 0xf5f5f5,
                        roughness: 0.4,
                        metalness: 0.0,
                        envMapIntensity: 0.2,
                    });
                    break;
                default: // black-wood
                    // Classic black wood with grain
                    const woodTexture = createWoodTexture();
                    frameMaterial = new THREE.MeshStandardMaterial({
                        color: 0x0f0f0f,
                        map: woodTexture,
                        roughness: 0.25,
                        metalness: 0.1,
                        envMapIntensity: 0.5,
                    });
            }

            // Top frame (clean, no visible bevels)
            const topFrame = new THREE.Mesh(
                new THREE.BoxGeometry(totalWidth + frameWidth * 2, frameWidth, frameDepth),
                frameMaterial
            );
            topFrame.position.set(0, totalHeight / 2 + frameWidth / 2, 0);
            topFrame.castShadow = true;
            frameGroup.add(topFrame);

            // Bottom frame
            const bottomFrame = new THREE.Mesh(
                new THREE.BoxGeometry(totalWidth + frameWidth * 2, frameWidth, frameDepth),
                frameMaterial
            );
            bottomFrame.position.set(0, -totalHeight / 2 - frameWidth / 2, 0);
            bottomFrame.castShadow = true;
            frameGroup.add(bottomFrame);

            // Left frame
            const leftFrame = new THREE.Mesh(
                new THREE.BoxGeometry(frameWidth, totalHeight, frameDepth),
                frameMaterial
            );
            leftFrame.position.set(-totalWidth / 2 - frameWidth / 2, 0, 0);
            leftFrame.castShadow = true;
            frameGroup.add(leftFrame);

            // Right frame
            const rightFrame = new THREE.Mesh(
                new THREE.BoxGeometry(frameWidth, totalHeight, frameDepth),
                frameMaterial
            );
            rightFrame.position.set(totalWidth / 2 + frameWidth / 2, 0, 0);
            rightFrame.castShadow = true;
            frameGroup.add(rightFrame);

            // === BACK PANEL (Dibond) ===
            const backGeometry = new THREE.PlaneGeometry(totalWidth, totalHeight);
            const backMaterial = new THREE.MeshStandardMaterial({
                color: 0xd5d5d5,
                roughness: 0.6,
                metalness: 0.4,
                side: THREE.BackSide,
            });
            const backMesh = new THREE.Mesh(backGeometry, backMaterial);
            backMesh.position.z = -frameDepth / 2 - 0.01;
            frameGroup.add(backMesh);

            // === ALUMINUM RAILS with professional details ===
            const railMaterial = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                roughness: 0.2,
                metalness: 0.9,
                envMapIntensity: 1.2,
            });

            const railWidth = totalWidth * 0.65;
            const railHeight = 0.06;
            const railDepth = 0.05;

            // Top rail
            const topRail = new THREE.Mesh(
                new THREE.BoxGeometry(railWidth, railHeight, railDepth),
                railMaterial
            );
            topRail.position.set(0, totalHeight * 0.4, -frameDepth / 2 - railDepth / 2 - 0.01);
            topRail.castShadow = true;
            frameGroup.add(topRail);

            // Bottom rail
            const bottomRail = new THREE.Mesh(
                new THREE.BoxGeometry(railWidth, railHeight, railDepth),
                railMaterial
            );
            bottomRail.position.set(0, -totalHeight * 0.4, -frameDepth / 2 - railDepth / 2 - 0.01);
            bottomRail.castShadow = true;
            frameGroup.add(bottomRail);

            // Mounting screws
            const screwMaterial = new THREE.MeshStandardMaterial({
                color: 0x404040,
                roughness: 0.3,
                metalness: 0.95,
            });

            const screwPositions = [
                [-railWidth / 3, totalHeight * 0.4],
                [railWidth / 3, totalHeight * 0.4],
                [-railWidth / 3, -totalHeight * 0.4],
                [railWidth / 3, -totalHeight * 0.4],
            ];

            screwPositions.forEach(([x, y]) => {
                const screw = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.018, 0.018, 0.008, 16),
                    screwMaterial
                );
                screw.position.set(x, y, -frameDepth / 2 - 0.008);
                screw.rotation.x = Math.PI / 2;
                frameGroup.add(screw);

                // Phillips head detail
                const slotGeom = new THREE.BoxGeometry(0.015, 0.001, 0.002);
                const slot1 = new THREE.Mesh(slotGeom, new THREE.MeshStandardMaterial({ color: 0x202020 }));
                slot1.position.set(x, y, -frameDepth / 2 - 0.004);
                frameGroup.add(slot1);

                const slot2 = new THREE.Mesh(slotGeom, new THREE.MeshStandardMaterial({ color: 0x202020 }));
                slot2.position.set(x, y, -frameDepth / 2 - 0.004);
                slot2.rotation.z = Math.PI / 2;
                frameGroup.add(slot2);
            });

            // Mounting holes in rails
            const holeMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.9,
                metalness: 0.1,
            });

            const holeRadius = 0.012;
            const numHoles = 6;

            for (let i = 0; i < numHoles; i++) {
                const xPos = -railWidth / 2 + (railWidth / (numHoles - 1)) * i;

                const topHole = new THREE.Mesh(
                    new THREE.CylinderGeometry(holeRadius, holeRadius, 0.006, 16),
                    holeMaterial
                );
                topHole.position.set(xPos, totalHeight * 0.4, -frameDepth / 2 - railDepth - 0.007);
                topHole.rotation.z = Math.PI / 2;
                frameGroup.add(topHole);

                const bottomHole = new THREE.Mesh(
                    new THREE.CylinderGeometry(holeRadius, holeRadius, 0.006, 16),
                    holeMaterial
                );
                bottomHole.position.set(xPos, -totalHeight * 0.4, -frameDepth / 2 - railDepth - 0.007);
                bottomHole.rotation.z = Math.PI / 2;
                frameGroup.add(bottomHole);
            }

            frameGroup.castShadow = true;
            frameGroup.receiveShadow = false;
            frameGroup.position.z = 1.5; // Position frame in front of the wall
            scene.add(frameGroup);

            document.getElementById('exportBtn').disabled = false;
            document.getElementById('showcaseBtn').disabled = false;
            document.getElementById('recordBtn').disabled = false;
        }

        function updateFrame() {
            if (currentTexture) createFramedPrint();
        }

        function startShowcase() {
            if (!frameGroup) {
                alert('Bitte laden Sie zuerst ein Bild hoch');
                return;
            }

            isShowcaseMode = true;
            showcaseStartTime = Date.now();
            showcaseAngle = 0;

            originalCameraPosition = camera.position.clone();
            originalControlsEnabled = controls.enabled;
            controls.enabled = false;

            // Intelligente Kamera-Positionierung basierend auf Frame-Dimensionen
            const optimalSettings = calculateOptimalShowcaseSettings();
            showcaseRadius = optimalSettings.radius;
            showcaseCameraHeight = optimalSettings.height;
            showcaseTargetZ = optimalSettings.targetZ;

            console.log(`Showcase Settings - Radius: ${showcaseRadius.toFixed(2)}m, Height: ${showcaseCameraHeight.toFixed(2)}m, TargetZ: ${showcaseTargetZ.toFixed(2)}m`);

            // UI Update
            document.getElementById('showcaseBtn').textContent = 'SHOWCASE STOPPEN';
            document.getElementById('showcaseBtn').classList.add('showcase-active');
        }

        function stopShowcase() {
            isShowcaseMode = false;

            if (originalCameraPosition) {
                camera.position.copy(originalCameraPosition);
            }
            controls.enabled = originalControlsEnabled !== null ? originalControlsEnabled : true;

            document.getElementById('showcaseBtn').textContent = 'SHOWCASE STARTEN';
            document.getElementById('showcaseBtn').classList.remove('showcase-active');
        }

        function toggleShowcase() {
            isShowcaseMode ? stopShowcase() : startShowcase();
        }

        function startRecording() {
            if (!frameGroup) {
                alert('Bitte laden Sie zuerst ein Bild hoch');
                return;
            }

            // Browser-Kompatibilit√§t pr√ºfen
            if (!HTMLCanvasElement.prototype.captureStream) {
                alert('Ihr Browser unterst√ºtzt keine Videoaufnahme. Bitte verwenden Sie Chrome, Firefox oder Edge.');
                return;
            }

            // Original-Einstellungen speichern
            originalRendererSize = {
                width: renderer.domElement.width,
                height: renderer.domElement.height
            };
            originalCameraAspect = camera.aspect;
            originalPixelRatio = renderer.getPixelRatio();

            // Performance-Optimierungen f√ºr fl√ºssige Aufnahme
            // Pixel Ratio auf 1 setzen f√ºr konsistente Performance
            renderer.setPixelRatio(1);

            // Zu 1:1 Aspect Ratio wechseln
            renderer.setSize(RECORDING_WIDTH, RECORDING_HEIGHT);
            camera.aspect = 1.0;
            camera.updateProjectionMatrix();

            // Showcase starten
            if (!isShowcaseMode) {
                startShowcase();
            }

            // Kamera-Position f√ºr quadratischen Viewport optimieren
            const recordingSettings = calculateOptimalShowcaseSettings(1.0);
            showcaseRadius = recordingSettings.radius;
            showcaseCameraHeight = recordingSettings.height;
            showcaseTargetZ = recordingSettings.targetZ;

            console.log(`Recording Mode - Optimized Radius: ${showcaseRadius.toFixed(2)}m, Height: ${showcaseCameraHeight.toFixed(2)}m, TargetZ: ${showcaseTargetZ.toFixed(2)}m`);

            // MediaRecorder einrichten
            const stream = renderer.domElement.captureStream(RECORDING_FPS);

            let options;
            let mimeType;
            let fileExtension;

            // Pr√ºfe beste Codec-Unterst√ºtzung
            if (MediaRecorder.isTypeSupported('video/webm; codecs=vp9')) {
                options = { mimeType: 'video/webm; codecs=vp9', videoBitsPerSecond: RECORDING_BITRATE };
                mimeType = 'video/webm';
                fileExtension = 'webm';
            } else if (MediaRecorder.isTypeSupported('video/webm; codecs=vp8')) {
                options = { mimeType: 'video/webm; codecs=vp8', videoBitsPerSecond: RECORDING_BITRATE };
                mimeType = 'video/webm';
                fileExtension = 'webm';
            } else if (MediaRecorder.isTypeSupported('video/webm; codecs=h264')) {
                options = { mimeType: 'video/webm; codecs=h264', videoBitsPerSecond: RECORDING_BITRATE };
                mimeType = 'video/webm';
                fileExtension = 'webm';
            } else {
                options = { mimeType: 'video/webm', videoBitsPerSecond: RECORDING_BITRATE };
                mimeType = 'video/webm';
                fileExtension = 'webm';
            }

            mediaRecorder = new MediaRecorder(stream, options);
            recordedChunks = [];

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `fine-art-showcase-${Date.now()}.${fileExtension}`;
                a.click();
                URL.revokeObjectURL(url);

                // Zeige Konvertierungs-Hinweis f√ºr MP4
                const message = `Video erfolgreich gespeichert als .${fileExtension}!\n\n` +
                    `F√ºr Instagram (MP4): Konvertieren Sie das Video mit:\n` +
                    `‚Ä¢ CloudConvert.com (kostenlos, online)\n` +
                    `‚Ä¢ HandBrake (kostenlos, Desktop)\n` +
                    `‚Ä¢ ffmpeg: ffmpeg -i input.webm output.mp4`;

                alert(message);
                recordedChunks = [];
                mediaRecorder = null;
            };

            mediaRecorder.start();
            isRecording = true;

            // UI Updates
            document.getElementById('recordingIndicator').style.display = 'block';
            document.getElementById('recordBtn').textContent = 'AUFNAHME ABBRECHEN';
            document.getElementById('recordBtn').classList.add('recording');
            document.getElementById('controls').style.display = 'none';
            document.getElementById('info').style.display = 'none';

            updateRecordingProgress();

            // Auto-stop nach einer Rotation
            setTimeout(() => {
                if (isRecording) {
                    stopRecording();
                }
            }, SHOWCASE_DURATION * 1000 + 500);
        }

        function stopRecording() {
            if (!isRecording || !mediaRecorder) return;

            isRecording = false;
            mediaRecorder.stop();
            stopShowcase();

            // Original-Einstellungen wiederherstellen
            renderer.setPixelRatio(originalPixelRatio);
            renderer.setSize(originalRendererSize.width, originalRendererSize.height);
            camera.aspect = originalCameraAspect;
            camera.updateProjectionMatrix();

            // UI wiederherstellen
            document.getElementById('controls').style.display = 'block';
            document.getElementById('info').style.display = 'block';
            document.getElementById('recordingIndicator').style.display = 'none';
            document.getElementById('recordBtn').textContent = 'VIDEO AUFNEHMEN (1:1)';
            document.getElementById('recordBtn').classList.remove('recording');
        }

        function updateRecordingProgress() {
            if (!isRecording) {
                document.getElementById('recordingProgress').style.width = '0%';
                return;
            }

            const elapsed = (Date.now() - showcaseStartTime) / 1000;
            const progress = Math.min((elapsed / SHOWCASE_DURATION) * 100, 100);
            document.getElementById('recordingProgress').style.width = `${progress}%`;

            requestAnimationFrame(updateRecordingProgress);
        }

        function cancelRecording() {
            if (!isRecording || !mediaRecorder) return;

            // Aufnahme abbrechen ohne Video zu speichern
            isRecording = false;

            // MediaRecorder stoppen ohne onstop-Handler (verhindert Download)
            const tempRecorder = mediaRecorder;
            tempRecorder.onstop = null; // Entfernt den Download-Handler
            tempRecorder.stop();

            mediaRecorder = null;
            recordedChunks = [];

            stopShowcase();

            // Original-Einstellungen wiederherstellen
            renderer.setPixelRatio(originalPixelRatio);
            renderer.setSize(originalRendererSize.width, originalRendererSize.height);
            camera.aspect = originalCameraAspect;
            camera.updateProjectionMatrix();

            // UI wiederherstellen
            document.getElementById('controls').style.display = 'block';
            document.getElementById('info').style.display = 'block';
            document.getElementById('recordingIndicator').style.display = 'none';
            document.getElementById('recordBtn').textContent = 'VIDEO AUFNEHMEN (1:1)';
            document.getElementById('recordBtn').classList.remove('recording');
        }

        function toggleRecording() {
            if (isRecording) {
                cancelRecording();
            } else {
                startRecording();
            }
        }

        function exportModel() {
            if (!frameGroup) return;

            document.getElementById('loading').style.display = 'block';

            const exporter = new GLTFExporter();
            exporter.parse(
                frameGroup,
                function(result) {
                    const blob = new Blob([result], { type: 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = 'fine-art-print-premium-' + Date.now() + '.glb';
                    link.click();
                    URL.revokeObjectURL(url);
                    document.getElementById('loading').style.display = 'none';
                },
                function(error) {
                    console.error('Export error:', error);
                    alert('Fehler beim Exportieren des Modells');
                    document.getElementById('loading').style.display = 'none';
                },
                { binary: true }
            );
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isShowcaseMode) {
                // Kreisf√∂rmige Kamera-Bewegung
                const elapsed = (Date.now() - showcaseStartTime) / 1000;
                showcaseAngle = elapsed * SHOWCASE_ROTATION_SPEED;

                camera.position.x = Math.sin(showcaseAngle) * showcaseRadius;
                camera.position.y = showcaseCameraHeight;
                camera.position.z = Math.cos(showcaseAngle) * showcaseRadius + showcaseTargetZ;
                camera.lookAt(0, 0, showcaseTargetZ);

                // Auto-stop nach einer Rotation (wenn nicht aufgenommen wird)
                if (!isRecording && elapsed >= SHOWCASE_DURATION) {
                    stopShowcase();
                }
            } else {
                controls.update();
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
