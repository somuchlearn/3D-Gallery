<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fine Art Print Konfigurator - Premium 3D Preview</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(to bottom, #e8e8e8, #d0d0d0);
            overflow: hidden;
            height: 100vh;
        }

        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        #controls {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.98);
            padding: 28px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0, 0, 0, 0.04);
            z-index: 100;
            max-width: 360px;
            border: 1px solid rgba(0, 0, 0, 0.06);
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 24px;
            margin-bottom: 6px;
            color: #111;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .subtitle {
            font-size: 13px;
            color: #666;
            margin-bottom: 24px;
            font-weight: 400;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: #333;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        input[type="file"] {
            display: none;
        }

        .file-upload-btn {
            display: block;
            width: 100%;
            padding: 16px;
            background: #000;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 1.2px;
        }

        .file-upload-btn:hover {
            background: #222;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        input[type="range"] {
            width: 100%;
            margin-top: 10px;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            border-radius: 2px;
            background: linear-gradient(to right, #000 0%, #ddd 0%);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #000;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #000;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .slider-value {
            display: inline-block;
            margin-left: 10px;
            color: #000;
            font-weight: 700;
            font-size: 13px;
        }

        select {
            width: 100%;
            padding: 14px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        select:hover {
            border-color: #000;
        }

        select:focus {
            outline: none;
            border-color: #000;
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.05);
        }

        button {
            width: 100%;
            padding: 16px;
            margin-top: 12px;
            background: #000;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 1.2px;
        }

        button:hover {
            background: #222;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        #info {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(255, 255, 255, 0.98);
            padding: 20px 24px;
            border-radius: 12px;
            color: #555;
            font-size: 13px;
            max-width: 300px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 0, 0, 0.06);
            backdrop-filter: blur(10px);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            padding: 48px 72px;
            border-radius: 16px;
            font-size: 16px;
            font-weight: 600;
            color: #000;
            display: none;
            z-index: 200;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(0, 0, 0, 0.06);
        }

        .specs {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #e8e8e8;
            font-size: 12px;
            color: #666;
        }

        .specs-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .specs-label {
            font-weight: 600;
            color: #333;
        }

        /* Recording Indicator */
        .recording-indicator {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(220, 38, 38, 0.95);
            color: white;
            padding: 16px 32px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            z-index: 150;
            display: none;
            box-shadow: 0 4px 16px rgba(220, 38, 38, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .recording-indicator::before {
            content: '‚óè';
            display: inline-block;
            margin-right: 10px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .recording-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0%;
            height: 4px;
            background: linear-gradient(to right, #dc2626, #ef4444);
            transition: width 0.1s linear;
        }

        button.recording {
            background: #dc2626 !important;
            animation: pulse 2s infinite;
        }

        button.showcase-active {
            background: #dc2626 !important;
        }

        /* Video Processing Overlay */
        .video-processing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(10px);
        }

        .video-processing-overlay.active {
            display: flex;
        }

        .processing-content {
            text-align: center;
            color: white;
            max-width: 500px;
            padding: 40px;
        }

        .processing-icon {
            font-size: 64px;
            margin-bottom: 24px;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .processing-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .processing-subtitle {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 32px;
        }

        .progress-container {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 16px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            font-size: 14px;
            color: #999;
        }

        .processing-steps {
            margin-top: 24px;
            text-align: left;
        }

        .processing-step {
            display: flex;
            align-items: center;
            padding: 8px 0;
            font-size: 13px;
            color: #666;
        }

        .processing-step.active {
            color: white;
        }

        .processing-step.completed {
            color: #10b981;
        }

        .step-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .processing-step.active .step-icon {
            border-color: #3b82f6;
            background: #3b82f6;
        }

        .processing-step.completed .step-icon {
            border-color: #10b981;
            background: #10b981;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>

        <div id="controls">
            <h1>Fine Art Print</h1>
            <div class="subtitle">Premium Gallery Konfigurator</div>

            <div class="control-group">
                <label for="imageUpload">Ihr Kunstwerk</label>
                <input type="file" id="imageUpload" accept="image/*">
                <button class="file-upload-btn" onclick="document.getElementById('imageUpload').click()">
                    Bild hochladen
                </button>
            </div>

            <div class="control-group">
                <label for="printSize">Bildgr√∂√üe</label>
                <select id="printSize">
                    <option value="0.5">30 x 40 cm</option>
                    <option value="0.75">50 x 70 cm</option>
                    <option value="1.0" selected>70 x 100 cm</option>
                    <option value="1.25">100 x 140 cm</option>
                    <option value="1.5">120 x 180 cm</option>
                </select>
            </div>

            <div class="control-group">
                <label for="passepartout">Passepartout</label>
                <select id="passepartout">
                    <option value="0" selected>Ohne Passepartout</option>
                    <option value="3">3 cm</option>
                    <option value="5">5 cm</option>
                    <option value="7">7 cm</option>
                    <option value="10">10 cm</option>
                </select>
            </div>

            <div class="control-group">
                <label for="frameWidth">
                    Rahmenbreite <span class="slider-value" id="frameWidthValue">1</span> cm
                </label>
                <input type="range" id="frameWidth" min="1" max="5" value="1" step="0.5">
            </div>

            <div class="control-group">
                <label for="frameDepth">
                    Rahmentiefe <span class="slider-value" id="frameDepthValue">2</span> cm
                </label>
                <input type="range" id="frameDepth" min="1" max="3" value="2" step="0.5">
            </div>

            <div class="control-group">
                <label for="frameMaterial">Rahmenmaterial</label>
                <select id="frameMaterial">
                    <option value="black-wood" selected>Schwarzes Holz</option>
                    <option value="black-aluminum">Aluminium Schwarz (Premium)</option>
                    <option value="oak">Eiche Natur</option>
                    <option value="walnut">Nussbaum Dunkel</option>
                    <option value="white-wood">Wei√ües Holz</option>
                </select>
            </div>

            <div class="control-group">
                <label for="glassEffect">Verglasung</label>
                <select id="glassEffect">
                    <option value="none" selected>Ohne Glas</option>
                    <option value="glass">Normalglas</option>
                    <option value="acrylic">Acrylglas</option>
                    <option value="museum">Museumsglas</option>
                </select>
            </div>

            <div class="control-group">
                <label>Showcase & Video</label>
                <button id="showcaseBtn" disabled>SHOWCASE STARTEN</button>
                <button id="recordBtn" disabled>VIDEO AUFNEHMEN (1:1)</button>
            </div>

            <button id="exportBtn" disabled>3D Modell exportieren</button>

            <div class="specs">
                <div class="specs-item">
                    <span class="specs-label">Material:</span>
                    <span>Aluminium-Dibond</span>
                </div>
                <div class="specs-item">
                    <span class="specs-label">Befestigung:</span>
                    <span>Alu-Schienen</span>
                </div>
                <div class="specs-item">
                    <span class="specs-label">Finish:</span>
                    <span>Matt Premium</span>
                </div>
            </div>
        </div>

        <div id="info">
            <strong>Navigation:</strong><br>
            Linke Maustaste: Rotieren<br>
            Rechte Maustaste: Verschieben<br>
            Mausrad: Zoomen
        </div>

        <div id="recordingIndicator" class="recording-indicator">
            AUFNAHME L√ÑUFT
            <div class="recording-progress" id="recordingProgress"></div>
        </div>

        <!-- Video Processing Overlay -->
        <div id="videoProcessingOverlay" class="video-processing-overlay">
            <div class="processing-content">
                <div class="processing-icon">üé¨</div>
                <div class="processing-title" id="processingTitle">Video wird erstellt...</div>
                <div class="processing-subtitle" id="processingSubtitle">Bitte warten Sie einen Moment</div>

                <div class="progress-container">
                    <div class="progress-bar" id="videoProgressBar"></div>
                </div>
                <div class="progress-text" id="videoProgressText">0%</div>

                <div class="processing-steps">
                    <div class="processing-step" id="step-recording">
                        <div class="step-icon"></div>
                        <span>Aufnahme wird erstellt</span>
                    </div>
                    <div class="processing-step" id="step-converting">
                        <div class="step-icon"></div>
                        <span>Konvertierung zu MP4</span>
                    </div>
                    <div class="processing-step" id="step-download">
                        <div class="step-icon"></div>
                        <span>Download wird vorbereitet</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="emptyState" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #666; font-size: 16px; pointer-events: none;">
            <div style="font-size: 64px; margin-bottom: 20px; opacity: 0.3;">üñºÔ∏è</div>
            <div style="font-weight: 600; margin-bottom: 10px;">Kein Bild geladen</div>
            <div style="font-size: 14px; opacity: 0.7;">Laden Sie ein Bild hoch, um die 3D-Vorschau zu sehen</div>
        </div>

        <div class="loading" id="loading">Wird verarbeitet...</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';
        import { FFmpeg } from '@ffmpeg/ffmpeg';
        import { fetchFile, toBlobURL } from '@ffmpeg/util';

        let scene, camera, renderer, controls;
        let frameGroup = null;
        let currentTexture = null;
        let galleryWall = null;

        // Showcase Mode State
        let isShowcaseMode = false;
        let showcaseStartTime = 0;
        let showcaseAngle = 0;
        let showcaseRadius = 8;
        let showcaseCameraHeight = 1.5;
        let showcaseTargetZ = 1.5; // Z-Position des Frame-Zentrums
        let originalCameraPosition = null;
        let originalControlsEnabled = null;

        // Recording State
        let isRecording = false;
        let mediaRecorder = null;
        let recordedChunks = [];
        let originalRendererSize = { width: 0, height: 0 };
        let originalCameraAspect = 0;
        let originalPixelRatio = 0;

        // FFmpeg State
        let ffmpeg = null;
        let ffmpegLoaded = false;

        // Configuration
        const SHOWCASE_ROTATION_SPEED = 0.898; // rad/sec (~7s f√ºr 360¬∞)
        const SHOWCASE_DURATION = Math.PI * 2 / SHOWCASE_ROTATION_SPEED;
        const RECORDING_WIDTH = 1080;
        const RECORDING_HEIGHT = 1080;
        const RECORDING_FPS = 60; // 60 FPS f√ºr maximale Fl√ºssigkeit
        const RECORDING_BITRATE = 12000000; // 12 Mbps f√ºr beste Qualit√§t

        // FFmpeg Initialisierung
        async function loadFFmpeg() {
            if (ffmpegLoaded) {
                console.log('FFmpeg bereits geladen, √ºberspringe...');
                return;
            }

            console.log('Erstelle neue FFmpeg Instanz...');
            ffmpeg = new FFmpeg();

            ffmpeg.on('log', ({ message }) => {
                console.log('[FFmpeg Log]', message);
            });

            ffmpeg.on('progress', ({ progress }) => {
                const percent = Math.round(progress * 100);
                console.log(`[FFmpeg Progress] ${percent}%`);
                updateProgress(50 + percent * 0.4, `Konvertierung l√§uft... ${percent}%`);
            });

            try {
                console.log('Lade FFmpeg Core Dateien von CDN...');

                // Use CDN for reliable loading in development and production
                const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/esm';

                try {
                    await ffmpeg.load({
                        coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
                        wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
                    });
                } catch (err) {
                    console.error('‚ùå ffmpeg.load() Fehler:', err);
                    console.error('Error Details:', JSON.stringify(err, Object.getOwnPropertyNames(err)));
                    throw new Error('ffmpeg.load() fehlgeschlagen: ' + (err.message || err));
                }

                ffmpegLoaded = true;
                console.log('‚úÖ FFmpeg erfolgreich geladen!');
            } catch (error) {
                console.error('‚ùå FFmpeg Load Fehler:', error);
                console.error('Error Type:', typeof error);
                console.error('Error Stack:', error.stack);
                throw new Error('FFmpeg konnte nicht geladen werden: ' + (error.message || 'Unbekannter Fehler'));
            }
        }

        // Image Enhancement Functions
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            return [h, s, l];
        }

        function hslToRgb(h, s, l) {
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function enhanceImage(img, contrastFactor = 1.4, saturationFactor = 1.3) {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');

            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                let r = data[i];
                let g = data[i + 1];
                let b = data[i + 2];

                // Convert to HSL for saturation adjustment
                let [h, s, l] = rgbToHsl(r, g, b);

                // Increase saturation
                s = Math.min(1, s * saturationFactor);

                // Convert back to RGB
                [r, g, b] = hslToRgb(h, s, l);

                // Apply contrast
                r = ((r / 255 - 0.5) * contrastFactor + 0.5) * 255;
                g = ((g / 255 - 0.5) * contrastFactor + 0.5) * 255;
                b = ((b / 255 - 0.5) * contrastFactor + 0.5) * 255;

                // Clamp values
                data[i] = Math.max(0, Math.min(255, r));
                data[i + 1] = Math.max(0, Math.min(255, g));
                data[i + 2] = Math.max(0, Math.min(255, b));
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        function extractDominantColors(img, numColors = 5) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Use smaller size for faster processing
            const sampleSize = 100;
            canvas.width = sampleSize;
            canvas.height = sampleSize;

            ctx.drawImage(img, 0, 0, sampleSize, sampleSize);
            const imageData = ctx.getImageData(0, 0, sampleSize, sampleSize);
            const data = imageData.data;

            // Sample every nth pixel for speed
            const colorMap = {};
            const step = 4; // Sample every 4th pixel

            for (let i = 0; i < data.length; i += step * 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];

                // Skip transparent pixels
                if (a < 128) continue;

                // Reduce color space to 32 levels per channel for clustering
                const rBucket = Math.floor(r / 32) * 32;
                const gBucket = Math.floor(g / 32) * 32;
                const bBucket = Math.floor(b / 32) * 32;

                const key = `${rBucket},${gBucket},${bBucket}`;
                colorMap[key] = (colorMap[key] || 0) + 1;
            }

            // Sort colors by frequency
            const sortedColors = Object.entries(colorMap)
                .sort((a, b) => b[1] - a[1])
                .slice(0, numColors)
                .map(([color]) => {
                    const [r, g, b] = color.split(',').map(Number);
                    return { r, g, b };
                });

            return sortedColors;
        }

        function adjustColorBrightness(color, amount) {
            const r = Math.max(0, Math.min(255, color.r + amount));
            const g = Math.max(0, Math.min(255, color.g + amount));
            const b = Math.max(0, Math.min(255, color.b + amount));
            return { r, g, b };
        }

        function createDynamicBackground(dominantColors) {
            if (!dominantColors || dominantColors.length === 0) {
                // Fallback to default gradient
                const canvas = document.createElement('canvas');
                canvas.width = 2;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createLinearGradient(0, 0, 0, 512);
                gradient.addColorStop(0, '#e8e8e8');
                gradient.addColorStop(1, '#d0d0d0');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 2, 512);
                return new THREE.CanvasTexture(canvas);
            }

            const canvas = document.createElement('canvas');
            canvas.width = 2;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Adjust colors for better background appearance (lighter)
            const adjustedColors = dominantColors.slice(0, 3).map(color => {
                // Calculate luminance
                const luminance = (0.299 * color.r + 0.587 * color.g + 0.114 * color.b) / 255;

                // Make dark colors lighter, light colors slightly darker for balance
                const adjustment = luminance < 0.4 ? 60 : luminance > 0.7 ? -20 : 20;
                return adjustColorBrightness(color, adjustment);
            });

            const gradient = ctx.createLinearGradient(0, 0, 0, 512);

            if (adjustedColors.length === 1) {
                const c = adjustedColors[0];
                gradient.addColorStop(0, `rgb(${c.r}, ${c.g}, ${c.b})`);
                gradient.addColorStop(1, `rgb(${Math.max(0, c.r - 40)}, ${Math.max(0, c.g - 40)}, ${Math.max(0, c.b - 40)})`);
            } else if (adjustedColors.length === 2) {
                const c1 = adjustedColors[0];
                const c2 = adjustedColors[1];
                gradient.addColorStop(0, `rgb(${c1.r}, ${c1.g}, ${c1.b})`);
                gradient.addColorStop(1, `rgb(${c2.r}, ${c2.g}, ${c2.b})`);
            } else {
                adjustedColors.forEach((color, index) => {
                    const stop = index / (adjustedColors.length - 1);
                    gradient.addColorStop(stop, `rgb(${color.r}, ${color.g}, ${color.b})`);
                });
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 2, 512);

            return new THREE.CanvasTexture(canvas);
        }

        // Overlay Helper Functions
        function showProcessingOverlay() {
            document.getElementById('videoProcessingOverlay').classList.add('active');
            document.getElementById('controls').style.display = 'none';
            document.getElementById('info').style.display = 'none';
        }

        function hideProcessingOverlay() {
            document.getElementById('videoProcessingOverlay').classList.remove('active');
            document.getElementById('controls').style.display = 'block';
            document.getElementById('info').style.display = 'block';
            resetProgress();
        }

        function updateProgress(percent, text) {
            document.getElementById('videoProgressBar').style.width = `${percent}%`;
            document.getElementById('videoProgressText').textContent = `${Math.round(percent)}%`;
            if (text) {
                document.getElementById('processingSubtitle').textContent = text;
            }
        }

        function updateStep(stepId, state) {
            const step = document.getElementById(`step-${stepId}`);
            if (!step) return;

            step.classList.remove('active', 'completed');
            if (state === 'active') {
                step.classList.add('active');
                const icon = step.querySelector('.step-icon');
                icon.innerHTML = '‚óè';
            } else if (state === 'completed') {
                step.classList.add('completed');
                const icon = step.querySelector('.step-icon');
                icon.innerHTML = '‚úì';
            }
        }

        function resetProgress() {
            updateProgress(0);
            ['recording', 'converting', 'download'].forEach(step => {
                const el = document.getElementById(`step-${step}`);
                el.classList.remove('active', 'completed');
                el.querySelector('.step-icon').innerHTML = '';
            });
        }

        // Easing-Funktion f√ºr sanfte Bewegungen
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Best Practice: BoundingBox-basierte Kamera-Positionierung
        function calculateOptimalShowcaseSettings(viewportAspectRatio = null) {
            if (!frameGroup) {
                return { radius: 10, height: 1.5 }; // Defaults
            }

            // BESTE METHODE: Verwende die tats√§chliche 3D BoundingBox des Frames
            const boundingBox = new THREE.Box3().setFromObject(frameGroup);
            const size = boundingBox.getSize(new THREE.Vector3());
            const center = boundingBox.getCenter(new THREE.Vector3());

            console.log('Frame Size:', {
                width: size.x.toFixed(3),
                height: size.y.toFixed(3),
                depth: size.z.toFixed(3)
            });

            // Maximale Dimension (wichtig f√ºr alle Orientierungen)
            const maxDimension = Math.max(size.x, size.y, size.z);

            // FOV = 35¬∞ (siehe camera setup)
            const fov = 35 * (Math.PI / 180);

            // Basis-Radius Berechnung mit gro√üz√ºgigem Puffer
            let optimalRadius = (maxDimension / 2) / Math.tan(fov / 2);

            // Gro√üz√ºgiger Puffer abh√§ngig vom Viewport
            if (viewportAspectRatio === 1.0) {
                // Recording Mode (1:1): Noch mehr Abstand!
                // Berechne Diagonale f√ºr worst-case
                const diagonal = Math.sqrt(size.x * size.x + size.y * size.y);
                const diagonalRadius = (diagonal / 2) / Math.tan(fov / 2);
                optimalRadius = Math.max(optimalRadius, diagonalRadius) * 1.8; // 80% extra Puffer
            } else {
                // Normaler Showcase Mode
                optimalRadius *= 1.6; // 60% Puffer
            }

            // Kamera-H√∂he: Exakt auf Frame-Zentrum
            const optimalHeight = center.y;

            console.log('Calculated Settings:', {
                radius: optimalRadius.toFixed(2) + 'm',
                height: optimalHeight.toFixed(2) + 'm',
                targetZ: center.z.toFixed(2) + 'm',
                mode: viewportAspectRatio === 1.0 ? 'Recording (1:1)' : 'Showcase'
            });

            return {
                radius: Math.max(optimalRadius, 6), // Minimum 6m Distanz
                height: Math.max(optimalHeight, 0.8), // Minimum 0.8m H√∂he
                targetZ: center.z // Z-Position des Frame-Zentrums
            };
        }

        function init() {
            scene = new THREE.Scene();

            // Gradient background for professional look
            const canvas = document.createElement('canvas');
            canvas.width = 2;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#e8e8e8');
            gradient.addColorStop(1, '#d0d0d0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 2, 512);
            const bgTexture = new THREE.CanvasTexture(canvas);
            scene.background = bgTexture;

            // No fog for clean infinity background

            camera = new THREE.PerspectiveCamera(
                35,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1, 10);

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                preserveDrawingBuffer: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            // Shadows disabled for better performance
            renderer.shadowMap.enabled = false;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.12; // Very smooth, professional feel
            controls.rotateSpeed = 0.8; // Controlled rotation
            controls.zoomSpeed = 0.8;
            controls.panSpeed = 0.5;
            controls.minDistance = 2.5; // Allow closer viewing
            controls.maxDistance = 12; // Tighter range for focused experience
            controls.maxPolarAngle = Math.PI; // Allow full rotation
            controls.target.set(0, 0, 1.5); // Target the frame center
            controls.enablePan = true;
            controls.screenSpacePanning = false;

            // Create simple environment for reflections
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            const envScene = new THREE.Scene();
            envScene.background = new THREE.Color(0xffffff);

            const envLight1 = new THREE.DirectionalLight(0xffffff, 2);
            envLight1.position.set(1, 1, 1);
            envScene.add(envLight1);

            const envLight2 = new THREE.AmbientLight(0xffffff, 1);
            envScene.add(envLight2);

            const envMap = pmremGenerator.fromScene(envScene).texture;
            scene.environment = envMap;

            // Gallery Wall - Removed for infinity background effect
            // createGalleryWall();

            // Optimized Lighting - Simple & Fast
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.8);
            scene.add(ambientLight);

            // Single directional light for definition
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
            mainLight.position.set(3, 5, 7);
            scene.add(mainLight);

            window.addEventListener('resize', onWindowResize, false);

            document.getElementById('imageUpload').addEventListener('change', handleImageUpload);
            document.getElementById('frameWidth').addEventListener('input', updateFrame);
            document.getElementById('frameDepth').addEventListener('input', updateFrame);
            document.getElementById('printSize').addEventListener('input', updateFrame);
            document.getElementById('passepartout').addEventListener('input', updateFrame);
            document.getElementById('frameMaterial').addEventListener('input', updateFrame);
            document.getElementById('glassEffect').addEventListener('input', updateFrame);
            document.getElementById('exportBtn').addEventListener('click', exportModel);
            document.getElementById('showcaseBtn').addEventListener('click', toggleShowcase);
            document.getElementById('recordBtn').addEventListener('click', toggleRecording);

            // Update range slider backgrounds
            updateSliderBackground('frameWidth');
            updateSliderBackground('frameDepth');

            animate();
        }

        function createGalleryWall() {
            // Subtle backdrop - only visible behind frame, no distracting floor
            const wallGeometry = new THREE.PlaneGeometry(15, 12);
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0xebebeb,
                roughness: 0.95,
                metalness: 0.0,
                opacity: 0.6,
                transparent: true,
            });
            galleryWall = new THREE.Mesh(wallGeometry, wallMaterial);
            galleryWall.position.z = -3.5;
            galleryWall.receiveShadow = true;
            scene.add(galleryWall);

            // No floor - clean product presentation
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateSliderBackground(sliderId) {
            const slider = document.getElementById(sliderId);
            const min = slider.min;
            const max = slider.max;
            const value = slider.value;
            const percentage = ((value - min) / (max - min)) * 100;
            slider.style.background = `linear-gradient(to right, #000 0%, #000 ${percentage}%, #ddd ${percentage}%, #ddd 100%)`;
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('loading').style.display = 'block';
            document.getElementById('emptyState').style.display = 'none';

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // Extract dominant colors for dynamic background
                    const dominantColors = extractDominantColors(img, 5);
                    console.log('Extracted dominant colors:', dominantColors);

                    // Update scene background with dynamic gradient
                    const backgroundTexture = createDynamicBackground(dominantColors);
                    scene.background = backgroundTexture;

                    // Create enhanced texture and framed print
                    createTextureFromImage(img);
                    createFramedPrint();
                    document.getElementById('loading').style.display = 'none';
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function createTextureFromImage(img) {
            // Enhance the image with increased contrast and saturation
            const enhancedCanvas = enhanceImage(img, 1.4, 1.3);

            const texture = new THREE.Texture(enhancedCanvas);
            texture.needsUpdate = true;
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            currentTexture = texture;
        }

        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Dark wood base
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, 512, 512);

            // Wood grain
            for (let i = 0; i < 100; i++) {
                ctx.strokeStyle = `rgba(${15 + Math.random() * 10}, ${15 + Math.random() * 10}, ${15 + Math.random() * 10}, ${0.3 + Math.random() * 0.3})`;
                ctx.lineWidth = Math.random() * 2;
                ctx.beginPath();
                const y = Math.random() * 512;
                ctx.moveTo(0, y);
                ctx.bezierCurveTo(
                    128, y + (Math.random() - 0.5) * 20,
                    384, y + (Math.random() - 0.5) * 20,
                    512, y
                );
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createFramedPrint() {
            if (!currentTexture) return;

            if (frameGroup) {
                scene.remove(frameGroup);
                frameGroup.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => {
                                if (m.map) m.map.dispose();
                                m.dispose();
                            });
                        } else {
                            if (child.material.map) child.material.map.dispose();
                            child.material.dispose();
                        }
                    }
                });
            }

            const frameWidth = parseFloat(document.getElementById('frameWidth').value) / 10;
            const frameDepth = parseFloat(document.getElementById('frameDepth').value) / 10;
            const printSizeMultiplier = parseFloat(document.getElementById('printSize').value);
            const passepartoutWidth = parseFloat(document.getElementById('passepartout').value) / 10;
            const glassType = document.getElementById('glassEffect').value;

            document.getElementById('frameWidthValue').textContent = (frameWidth * 10).toFixed(1);
            document.getElementById('frameDepthValue').textContent = (frameDepth * 10).toFixed(1);

            updateSliderBackground('frameWidth');
            updateSliderBackground('frameDepth');

            const img = currentTexture.image;
            const aspectRatio = img.width / img.height;

            const printHeight = 4 * printSizeMultiplier;
            const printWidth = printHeight * aspectRatio;

            const totalWidth = printWidth + (passepartoutWidth * 2);
            const totalHeight = printHeight + (passepartoutWidth * 2);

            frameGroup = new THREE.Group();

            // === PASSEPARTOUT (simple and clean) ===
            if (passepartoutWidth > 0) {
                // Main passepartout with subtle thickness
                const passepartoutThickness = 0.003;
                const passepartoutGeometry = new THREE.BoxGeometry(totalWidth, totalHeight, passepartoutThickness);
                const passepartoutMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf5f5f2,
                    roughness: 0.9,
                    metalness: 0.0,
                });
                const passepartoutMesh = new THREE.Mesh(passepartoutGeometry, passepartoutMaterial);
                passepartoutMesh.position.z = -0.015;
                passepartoutMesh.castShadow = true;
                frameGroup.add(passepartoutMesh);
            }

            // === PRINT (Fine Art Paper with enhanced brilliance) ===
            const printGeometry = new THREE.PlaneGeometry(printWidth, printHeight);
            const printMaterial = new THREE.MeshStandardMaterial({
                map: currentTexture,
                roughness: 0.15, // Reduced from 0.7 for glossier, more vibrant appearance
                metalness: 0.0,
                side: THREE.FrontSide,
            });
            const printMesh = new THREE.Mesh(printGeometry, printMaterial);
            printMesh.position.z = 0;
            printMesh.castShadow = true;
            frameGroup.add(printMesh);

            // === GLASS with realistic 3D thickness ===
            if (glassType !== 'none') {
                let transmission, glassRoughness, reflectivity, glassThickness;

                switch(glassType) {
                    case 'museum':
                        transmission = 0.98;
                        glassRoughness = 0.01;
                        reflectivity = 0.03;
                        glassThickness = 0.002;
                        break;
                    case 'acrylic':
                        transmission = 0.96;
                        glassRoughness = 0.03;
                        reflectivity = 0.06;
                        glassThickness = 0.004;
                        break;
                    default:
                        transmission = 0.94;
                        glassRoughness = 0.05;
                        reflectivity = 0.08;
                        glassThickness = 0.003;
                }

                // Use BoxGeometry for realistic glass thickness visible from side
                const glassGeometry = new THREE.BoxGeometry(totalWidth, totalHeight, glassThickness);
                // Crystal-clear glass without milky transmission effect
                const glassMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.05, // Almost invisible, just subtle reflections
                    roughness: 0.02, // Very smooth for clarity
                    metalness: 0.0,
                    transmission: 0, // No transmission = no milky effect
                    ior: 1.52,
                    reflectivity: 0.15, // Subtle realistic glass reflections
                    envMapIntensity: 0.3, // Minimal environment reflections
                    clearcoat: 1.0, // High clearcoat for glass shine
                    clearcoatRoughness: 0.02, // Very smooth clearcoat
                });

                const glassMesh = new THREE.Mesh(glassGeometry, glassMaterial);
                glassMesh.position.z = 0.05;
                frameGroup.add(glassMesh);
            }

            // === FRAME with premium materials ===
            const selectedMaterial = document.getElementById('frameMaterial').value;
            let frameMaterial;

            switch(selectedMaterial) {
                case 'black-aluminum':
                    // Premium black aluminum - sleek and modern
                    frameMaterial = new THREE.MeshStandardMaterial({
                        color: 0x1a1a1a,
                        roughness: 0.15,
                        metalness: 0.9,
                        envMapIntensity: 1.2,
                    });
                    break;
                case 'oak':
                    // Natural oak wood
                    const oakTexture = createWoodTexture();
                    frameMaterial = new THREE.MeshStandardMaterial({
                        color: 0xc19a6b,
                        map: oakTexture,
                        roughness: 0.6,
                        metalness: 0.0,
                        envMapIntensity: 0.3,
                    });
                    break;
                case 'walnut':
                    // Dark walnut wood
                    const walnutTexture = createWoodTexture();
                    frameMaterial = new THREE.MeshStandardMaterial({
                        color: 0x3e2723,
                        map: walnutTexture,
                        roughness: 0.35,
                        metalness: 0.05,
                        envMapIntensity: 0.4,
                    });
                    break;
                case 'white-wood':
                    // White painted wood
                    frameMaterial = new THREE.MeshStandardMaterial({
                        color: 0xf5f5f5,
                        roughness: 0.4,
                        metalness: 0.0,
                        envMapIntensity: 0.2,
                    });
                    break;
                default: // black-wood
                    // Classic black wood with grain
                    const woodTexture = createWoodTexture();
                    frameMaterial = new THREE.MeshStandardMaterial({
                        color: 0x0f0f0f,
                        map: woodTexture,
                        roughness: 0.25,
                        metalness: 0.1,
                        envMapIntensity: 0.5,
                    });
            }

            // Top frame (clean, no visible bevels)
            const topFrame = new THREE.Mesh(
                new THREE.BoxGeometry(totalWidth + frameWidth * 2, frameWidth, frameDepth),
                frameMaterial
            );
            topFrame.position.set(0, totalHeight / 2 + frameWidth / 2, 0);
            topFrame.castShadow = true;
            frameGroup.add(topFrame);

            // Bottom frame
            const bottomFrame = new THREE.Mesh(
                new THREE.BoxGeometry(totalWidth + frameWidth * 2, frameWidth, frameDepth),
                frameMaterial
            );
            bottomFrame.position.set(0, -totalHeight / 2 - frameWidth / 2, 0);
            bottomFrame.castShadow = true;
            frameGroup.add(bottomFrame);

            // Left frame
            const leftFrame = new THREE.Mesh(
                new THREE.BoxGeometry(frameWidth, totalHeight, frameDepth),
                frameMaterial
            );
            leftFrame.position.set(-totalWidth / 2 - frameWidth / 2, 0, 0);
            leftFrame.castShadow = true;
            frameGroup.add(leftFrame);

            // Right frame
            const rightFrame = new THREE.Mesh(
                new THREE.BoxGeometry(frameWidth, totalHeight, frameDepth),
                frameMaterial
            );
            rightFrame.position.set(totalWidth / 2 + frameWidth / 2, 0, 0);
            rightFrame.castShadow = true;
            frameGroup.add(rightFrame);

            // === BACK PANEL (Dibond) ===
            const backGeometry = new THREE.PlaneGeometry(totalWidth, totalHeight);
            const backMaterial = new THREE.MeshStandardMaterial({
                color: 0xd5d5d5,
                roughness: 0.6,
                metalness: 0.4,
                side: THREE.BackSide,
            });
            const backMesh = new THREE.Mesh(backGeometry, backMaterial);
            backMesh.position.z = -frameDepth / 2 - 0.01;
            frameGroup.add(backMesh);

            // === ALUMINUM RAILS with professional details ===
            const railMaterial = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                roughness: 0.2,
                metalness: 0.9,
                envMapIntensity: 1.2,
            });

            const railWidth = totalWidth * 0.65;
            const railHeight = 0.06;
            const railDepth = 0.05;

            // Top rail
            const topRail = new THREE.Mesh(
                new THREE.BoxGeometry(railWidth, railHeight, railDepth),
                railMaterial
            );
            topRail.position.set(0, totalHeight * 0.4, -frameDepth / 2 - railDepth / 2 - 0.01);
            topRail.castShadow = true;
            frameGroup.add(topRail);

            // Bottom rail
            const bottomRail = new THREE.Mesh(
                new THREE.BoxGeometry(railWidth, railHeight, railDepth),
                railMaterial
            );
            bottomRail.position.set(0, -totalHeight * 0.4, -frameDepth / 2 - railDepth / 2 - 0.01);
            bottomRail.castShadow = true;
            frameGroup.add(bottomRail);

            // Mounting screws
            const screwMaterial = new THREE.MeshStandardMaterial({
                color: 0x404040,
                roughness: 0.3,
                metalness: 0.95,
            });

            const screwPositions = [
                [-railWidth / 3, totalHeight * 0.4],
                [railWidth / 3, totalHeight * 0.4],
                [-railWidth / 3, -totalHeight * 0.4],
                [railWidth / 3, -totalHeight * 0.4],
            ];

            screwPositions.forEach(([x, y]) => {
                const screw = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.018, 0.018, 0.008, 16),
                    screwMaterial
                );
                screw.position.set(x, y, -frameDepth / 2 - 0.008);
                screw.rotation.x = Math.PI / 2;
                frameGroup.add(screw);

                // Phillips head detail
                const slotGeom = new THREE.BoxGeometry(0.015, 0.001, 0.002);
                const slot1 = new THREE.Mesh(slotGeom, new THREE.MeshStandardMaterial({ color: 0x202020 }));
                slot1.position.set(x, y, -frameDepth / 2 - 0.004);
                frameGroup.add(slot1);

                const slot2 = new THREE.Mesh(slotGeom, new THREE.MeshStandardMaterial({ color: 0x202020 }));
                slot2.position.set(x, y, -frameDepth / 2 - 0.004);
                slot2.rotation.z = Math.PI / 2;
                frameGroup.add(slot2);
            });

            // Mounting holes in rails
            const holeMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.9,
                metalness: 0.1,
            });

            const holeRadius = 0.012;
            const numHoles = 6;

            for (let i = 0; i < numHoles; i++) {
                const xPos = -railWidth / 2 + (railWidth / (numHoles - 1)) * i;

                const topHole = new THREE.Mesh(
                    new THREE.CylinderGeometry(holeRadius, holeRadius, 0.006, 16),
                    holeMaterial
                );
                topHole.position.set(xPos, totalHeight * 0.4, -frameDepth / 2 - railDepth - 0.007);
                topHole.rotation.z = Math.PI / 2;
                frameGroup.add(topHole);

                const bottomHole = new THREE.Mesh(
                    new THREE.CylinderGeometry(holeRadius, holeRadius, 0.006, 16),
                    holeMaterial
                );
                bottomHole.position.set(xPos, -totalHeight * 0.4, -frameDepth / 2 - railDepth - 0.007);
                bottomHole.rotation.z = Math.PI / 2;
                frameGroup.add(bottomHole);
            }

            frameGroup.castShadow = true;
            frameGroup.receiveShadow = false;
            frameGroup.position.z = 1.5; // Position frame in front of the wall
            scene.add(frameGroup);

            document.getElementById('exportBtn').disabled = false;
            document.getElementById('showcaseBtn').disabled = false;
            document.getElementById('recordBtn').disabled = false;
        }

        function updateFrame() {
            if (currentTexture) createFramedPrint();
        }

        function startShowcase() {
            if (!frameGroup) {
                alert('Bitte laden Sie zuerst ein Bild hoch');
                return;
            }

            isShowcaseMode = true;
            showcaseStartTime = Date.now();
            showcaseAngle = 0;

            originalCameraPosition = camera.position.clone();
            originalControlsEnabled = controls.enabled;
            controls.enabled = false;

            // Intelligente Kamera-Positionierung basierend auf Frame-Dimensionen
            const optimalSettings = calculateOptimalShowcaseSettings();
            showcaseRadius = optimalSettings.radius;
            showcaseCameraHeight = optimalSettings.height;
            showcaseTargetZ = optimalSettings.targetZ;

            console.log(`Showcase Settings - Radius: ${showcaseRadius.toFixed(2)}m, Height: ${showcaseCameraHeight.toFixed(2)}m, TargetZ: ${showcaseTargetZ.toFixed(2)}m`);

            // UI Update
            document.getElementById('showcaseBtn').textContent = 'SHOWCASE STOPPEN';
            document.getElementById('showcaseBtn').classList.add('showcase-active');
        }

        function stopShowcase() {
            isShowcaseMode = false;

            if (originalCameraPosition) {
                camera.position.copy(originalCameraPosition);
            }
            controls.enabled = originalControlsEnabled !== null ? originalControlsEnabled : true;

            document.getElementById('showcaseBtn').textContent = 'SHOWCASE STARTEN';
            document.getElementById('showcaseBtn').classList.remove('showcase-active');
        }

        function toggleShowcase() {
            isShowcaseMode ? stopShowcase() : startShowcase();
        }

        async function startRecording() {
            console.log('startRecording() aufgerufen');

            if (!frameGroup) {
                alert('Bitte laden Sie zuerst ein Bild hoch');
                return;
            }

            // Browser-Kompatibilit√§t pr√ºfen
            if (!HTMLCanvasElement.prototype.captureStream) {
                alert('Ihr Browser unterst√ºtzt keine Videoaufnahme. Bitte verwenden Sie Chrome, Firefox oder Edge.');
                return;
            }

            try {
                console.log('Zeige Processing Overlay...');
                // Zeige Processing Overlay
                showProcessingOverlay();
                updateStep('recording', 'active');
                updateProgress(0, 'FFmpeg wird geladen...');
                console.log('Progress auf 0% gesetzt');

                // Lade FFmpeg wenn n√∂tig
                if (!ffmpegLoaded) {
                    console.log('Lade FFmpeg...');
                    await loadFFmpeg();
                    console.log('FFmpeg geladen!');
                }

                console.log('Bereite Aufnahme vor...');
                updateProgress(10, 'Aufnahme wird vorbereitet...');

                // Original-Einstellungen speichern
                originalRendererSize = {
                    width: renderer.domElement.width,
                    height: renderer.domElement.height
                };
                originalCameraAspect = camera.aspect;
                originalPixelRatio = renderer.getPixelRatio();

                // Performance-Optimierungen
                renderer.setPixelRatio(1);
                renderer.setSize(RECORDING_WIDTH, RECORDING_HEIGHT);
                camera.aspect = 1.0;
                camera.updateProjectionMatrix();

                // Showcase starten (unsichtbar im Hintergrund)
                if (!isShowcaseMode) {
                    startShowcase();
                }

                // Kamera-Position optimieren
                const recordingSettings = calculateOptimalShowcaseSettings(1.0);
                showcaseRadius = recordingSettings.radius;
                showcaseCameraHeight = recordingSettings.height;
                showcaseTargetZ = recordingSettings.targetZ;

                updateProgress(15, 'Video wird aufgenommen...');

                // MediaRecorder einrichten
                const stream = renderer.domElement.captureStream(RECORDING_FPS);
                const options = MediaRecorder.isTypeSupported('video/webm; codecs=vp9')
                    ? { mimeType: 'video/webm; codecs=vp9', videoBitsPerSecond: RECORDING_BITRATE }
                    : { mimeType: 'video/webm', videoBitsPerSecond: RECORDING_BITRATE };

                mediaRecorder = new MediaRecorder(stream, options);
                recordedChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    try {
                        updateStep('recording', 'completed');
                        updateStep('converting', 'active');
                        updateProgress(50, 'Video wird zu MP4 konvertiert...');

                        // WebM Blob erstellen
                        const webmBlob = new Blob(recordedChunks, { type: 'video/webm' });

                        // Konvertiere zu MP4
                        const mp4Blob = await convertWebMToMP4(webmBlob);

                        updateStep('converting', 'completed');
                        updateStep('download', 'active');
                        updateProgress(95, 'Download wird vorbereitet...');

                        // MP4 Download
                        const url = URL.createObjectURL(mp4Blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `fine-art-showcase-${Date.now()}.mp4`;
                        a.click();
                        URL.revokeObjectURL(url);

                        updateStep('download', 'completed');
                        updateProgress(100, 'Fertig!');

                        // Kurze Pause dann Overlay ausblenden
                        setTimeout(() => {
                            hideProcessingOverlay();
                        }, 1500);

                    } catch (error) {
                        console.error('Konvertierungs-Fehler:', error);
                        alert('Fehler bei der MP4-Konvertierung. Bitte versuchen Sie es erneut.');
                        hideProcessingOverlay();
                    } finally {
                        recordedChunks = [];
                        mediaRecorder = null;
                    }
                };

                mediaRecorder.start();
                isRecording = true;

                // Simuliere Progress w√§hrend Aufnahme
                const recordingDuration = SHOWCASE_DURATION * 1000;
                const progressInterval = setInterval(() => {
                    if (!isRecording) {
                        clearInterval(progressInterval);
                        return;
                    }
                    const elapsed = Date.now() - showcaseStartTime;
                    const progress = Math.min((elapsed / recordingDuration) * 35 + 15, 50);
                    updateProgress(progress, 'Aufnahme l√§uft...');
                }, 100);

                // Auto-stop nach einer Rotation
                setTimeout(() => {
                    if (isRecording) {
                        clearInterval(progressInterval);
                        stopRecording();
                    }
                }, recordingDuration + 500);

            } catch (error) {
                console.error('Recording-Fehler:', error);
                console.error('Error Stack:', error.stack);
                alert('Fehler beim Starten der Aufnahme: ' + error.message);
                hideProcessingOverlay();
            }
        }

        async function convertWebMToMP4(webmBlob) {
            // WebM in FFmpeg schreiben
            await ffmpeg.writeFile('input.webm', await fetchFile(webmBlob));

            // Konvertierung zu MP4
            await ffmpeg.exec([
                '-i', 'input.webm',
                '-c:v', 'libx264',
                '-preset', 'fast',
                '-crf', '22',
                '-c:a', 'aac',
                '-b:a', '128k',
                '-movflags', '+faststart',
                'output.mp4'
            ]);

            // MP4 auslesen
            const data = await ffmpeg.readFile('output.mp4');

            // Cleanup
            await ffmpeg.deleteFile('input.webm');
            await ffmpeg.deleteFile('output.mp4');

            return new Blob([data.buffer], { type: 'video/mp4' });
        }

        function stopRecording() {
            if (!isRecording || !mediaRecorder) return;

            isRecording = false;
            mediaRecorder.stop(); // Dies triggert mediaRecorder.onstop
            stopShowcase();

            // Original-Einstellungen wiederherstellen
            renderer.setPixelRatio(originalPixelRatio);
            renderer.setSize(originalRendererSize.width, originalRendererSize.height);
            camera.aspect = originalCameraAspect;
            camera.updateProjectionMatrix();
        }

        function updateRecordingProgress() {
            if (!isRecording) {
                document.getElementById('recordingProgress').style.width = '0%';
                return;
            }

            const elapsed = (Date.now() - showcaseStartTime) / 1000;
            const progress = Math.min((elapsed / SHOWCASE_DURATION) * 100, 100);
            document.getElementById('recordingProgress').style.width = `${progress}%`;

            requestAnimationFrame(updateRecordingProgress);
        }

        function cancelRecording() {
            if (!isRecording || !mediaRecorder) return;

            // Aufnahme abbrechen ohne Video zu speichern
            isRecording = false;

            // MediaRecorder stoppen ohne onstop-Handler (verhindert Download)
            const tempRecorder = mediaRecorder;
            tempRecorder.onstop = null; // Entfernt den Download-Handler
            tempRecorder.stop();

            mediaRecorder = null;
            recordedChunks = [];

            stopShowcase();

            // Original-Einstellungen wiederherstellen
            renderer.setPixelRatio(originalPixelRatio);
            renderer.setSize(originalRendererSize.width, originalRendererSize.height);
            camera.aspect = originalCameraAspect;
            camera.updateProjectionMatrix();

            // UI wiederherstellen
            document.getElementById('controls').style.display = 'block';
            document.getElementById('info').style.display = 'block';
            document.getElementById('recordingIndicator').style.display = 'none';
            document.getElementById('recordBtn').textContent = 'VIDEO AUFNEHMEN (1:1)';
            document.getElementById('recordBtn').classList.remove('recording');
        }

        function toggleRecording() {
            // Da die Aufnahme jetzt mit Overlay l√§uft, gibt es kein Cancel mehr
            // Der Button ist w√§hrend der Verarbeitung automatisch disabled
            if (!isRecording) {
                startRecording();
            }
        }

        function exportModel() {
            if (!frameGroup) return;

            document.getElementById('loading').style.display = 'block';

            const exporter = new GLTFExporter();
            exporter.parse(
                frameGroup,
                function(result) {
                    const blob = new Blob([result], { type: 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = 'fine-art-print-premium-' + Date.now() + '.glb';
                    link.click();
                    URL.revokeObjectURL(url);
                    document.getElementById('loading').style.display = 'none';
                },
                function(error) {
                    console.error('Export error:', error);
                    alert('Fehler beim Exportieren des Modells');
                    document.getElementById('loading').style.display = 'none';
                },
                { binary: true }
            );
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isShowcaseMode) {
                // Kreisf√∂rmige Kamera-Bewegung
                const elapsed = (Date.now() - showcaseStartTime) / 1000;
                showcaseAngle = elapsed * SHOWCASE_ROTATION_SPEED;

                camera.position.x = Math.sin(showcaseAngle) * showcaseRadius;
                camera.position.y = showcaseCameraHeight;
                camera.position.z = Math.cos(showcaseAngle) * showcaseRadius + showcaseTargetZ;
                camera.lookAt(0, 0, showcaseTargetZ);

                // Auto-stop nach einer Rotation (wenn nicht aufgenommen wird)
                if (!isRecording && elapsed >= SHOWCASE_DURATION) {
                    stopShowcase();
                }
            } else {
                controls.update();
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
